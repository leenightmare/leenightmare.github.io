# 数据类型

> 基本数据类型

**整数：**

整型：int

短整型：short int

长整型：long int



**浮点数**

单精度——float

双精度——double



**字符**

char



> 复合数据类型

结构体

枚举

共用体



变量为什么**要初始化**



**什么是字节**

字节就是存储数据的单位，并且是硬盘所能访问的最小单位



# scanf()和printf()

scanf() //接收键盘输入



## printf()



四种用法

```c
1.printf("字符串")

2.printf("输出控制符",输出参数)
    
3.printf("输出控制符1 输出控制符2...",输出参数1)

4.printf("输出控制符 非输出控制符",输出参数)
```



输出控制符包含如下

| %d                | int                                     |
| ----------------- | --------------------------------------- |
| %ld               | long int                                |
| %c                | char                                    |
| %f                | 单精度浮点输出 float                    |
| %lf               | 双精度浮点输出 double                   |
| %x(或者%X或者%#X) | 十六进制输出 int 、long  int、short int |
| %o                | 同上                                    |
| %s                | 字符串                                  |



## scanf() 【通过键盘将数据输入到变量中】

两种用法：
	用法一：scanf("输入控制符"，输入参数);

​	功能：将从键盘输入的字符转化为输入控制符所规定格式的数据，然后存入以输入参数的值为地址的变量中



​	用法一：scanf("非输入控制符  输入控制符"，输入参数);

​	功能：将从键盘输入的字符转化为输入控制符所规定格式的数据，然后存入以输入参数的值为地址的变量中

​				非输入控制符必须原样输入

```c
#include<stdio.h>
int main(void) {
	int num;
	printf ("请输入数字：");
	scanf_s ("%d",&num);//假设用户输入123
	printf ("num = %d\n",num);//打印输出123
	return 0;
}

```



>  注意：

1、&为取地址符，scanf中的输入参数必须要用&来指定地址

2、输入控制符和输入参数可以有多个

```c
#include<stdio.h>
int main(void) {
	int num;
	printf ("请输入数字：");
	scanf_s ("xxx%dxxx",&num);
    //当在非输入控制符%d前输入了xxx后，用户在输入数字时，也必须要在前面输入xxx，否则数据会出错
    //假设用户输入123，数据出错。假设输入xxx123xxx，打印输出123
	printf ("num = %d\n",num);
    
	return 0;
}
```

3、在visual studio 2019中，调用scanf函数时需要在后面加上_s，即scanf_s()，否则可能会报错



**关于计算机读取用户输入的值**

scanf()函数中，等待用户键盘输入字符，用户输入字符并敲回车键后，计算机把用户输入的值保存在缓冲内存，然后从缓冲内存中读取数据赋给输入参数进行匹配，如scanf_s ("%d",&num); 中，用户输入123，则num等于123。如果用户输入了123abc...,那么还是把123赋给num，但是abc会遗留在缓冲内存中，当再需要调用scanf函数时，会先读取在缓冲内存中的abc进行匹配。

```c
#include<stdio.h>
int main(void) {
	int j,k;
	printf ("请输入数字：");//假设用户输入123abc
	scanf_s ("%d",&j);//
	printf ("j = %d\n",j);//正常打印输入123
    
    scanf_s ("%d",&k);//
	printf ("k = %d\n",k);//数据出错
	return 0;
}
/*
	在visual studio 2019 中的运行结果：
	请输入数字：123abc
    j = 123
    k = -858993460
*/

/*解决方法，在下次调用scanf函数前添加以下代码
	char ch;
	while ((ch = getchar()) != '\n')
		continue;
*/
```

>  如何使用scanf编写高质量代码

​	1、使用scanf之间最好先使用printf提示用户以什么样方式来输入

​	2、scanf中尽量不要使用非输入控制符，尤其是不要用\n

​	3、应该编写代码对用户的非法输入做适当的处理



# 运算符

算数运算符 ：+ - * / %

关系运算符 ：>  <  >=  <=  ==  !=

逻辑运算符： 逻辑非!   短路或 ||   短路且 &&

优先级别：

算术>关系>逻辑>赋值

三目运算符

​	A?B:C

逗号运算符：

​	格式：(A,B,C,D);

​	最终表达式的值是最后一项的值。



**c语言对真假的处理**

非零是真，真是1表示

零是假，假是0表示

&&左边的表达式为假，会发生短路现象，右边的表达式不会执行

||左边的表达式为真，会发生短路现象，右边的表达式不会执行

```c
# include <stdio.h>
int main(void){
   int j=10;
   int k=20;
   int m;
   m= (3>2) && (k=8); //真，m等于1
   printf("j = %d, k = %d\n", j , k);//j = 10, k = 8, m = 1
   return 0;
}
# include <stdio.h>
int main(void){
   int j=10;
   int k=20;
   int m;
   m= (2>3) && (k=8); //假，m等于0，且短路，后面k=8不执行
   printf("j = %d, k = %d\n", j , k);//j = 10, k = 20, m = 0
   return 0;
}
```





# 流程控制

## if()

1、格式

2、if的范围问题

3、if...else...的用法

4、if...else if... else...的用法

5、C语言对真假的处理

6、if举例——求分数的等级

7、if的常见问题解析

switch



for

while

do...while

# 数组

为什么需要数组：为了解决大量同类型数据的存储和使用问题



数组的分类：

一维数组、二维数组、多维数组

定义：

​	为n个变量连续分配存储空间

​	所有的变量数据类型必须相同

​	所有变量所占的字节大小必须相等

例子：

​	int a[5] = {1,2,3,4,5}

**有关一维数组的操作**

初始化

​	完全初始化：int a[5] = {1,2,3,4,5}    

​	不完全初始化，未初始化的元素自动赋值为0： int a[5] = {1,2,3}

​	不初始化，所有元素都是垃圾值：int a[5]

​	清零：int a[5] = {0};

错误写法：int a[5]; a[5] = {1,2,3,4,5} 	//只有在定义数组的同时才能整体赋值 

赋值、排序、求最大/小值、倒置、查找

n维数组可以当做每个元素是n-1维数组的一维数组



注意：

​	1、一维数组名为该数组第一个元素的地址

```c
int a[5];
printf("%d",a);
printf("%d",&a[0]);

//以上两个输出结果相同
```



# 函数

为什么需要函数

​	避免重复性操作

​	有利于程序的模块化

什么是函数

​	能够完成特定功能的代码块

如何定义函数

​	函数返回值类型  函数名(形式参数列表){

​		函数体；

​	}



函数返回值类型与定义函数时的返回值类型为准

```c
# include <stdio.h>
int a(){
    return 10.5;
}

int main (void){
    int num = a();//此时a（）返回的值是int类型，即返回10    
    return 0;
}

```



函数声明

一、如果函数调用写在了函数定义的前面，则必须加函数前置声明

二、函数前置声明：

​	1、告诉编译器即将可能出现的若干个字母代表的是一个函数

​	2、告诉编译器即将可能出现的若干个字母所代表的函数形参和返回值的具体情况

​	3、函数声明是一个语句，末尾必须加分号

​	4、对库函数的声明是通过# include <库函数所在的文件的名字.h>来实现的



```c
# include<stdio.h>
//函数声明
int a(void);
int main (){
    a();//报错，因为编译从上到下，解决方法，函数声明。    
    return 0;
}

int a(void){
   	return;
}
```





变量的作用域和存储方式

​	作用域：全局变量（在函数外部定义的变量）、局部变量

​	按变量的存储方式：静态变量、自动变量、寄存器变量



# 指针

前言

```c
# include<stdio.h>
int main (){
	int * p;
/*
1、p是变量的名字，int*表示p变量存放的是int类型变量的地址。
2、int * p不表示定义了一个名字叫做*p的变量
3、所谓int *类型就是存放int变量地址的类型
    
    */
    int i = 3;
    
    p = &i;
/*
1、p保存了i的地址，因此p指向i
2、p不是i，i也不是p，更准确地说，修改p的值不影响i的值，修改i的值不影响i的值
3、如果一个指针变量指向了某个普通变量，则*变量指针变量就完全等同于普通变量
例子：
	如果p是个指针变量，并且p存放了普通变量i的地址，则p指向了普通变量i，*p就完全等同于i
	或者说：在所有出现*p的地方都可以替换成i，反之亦可。
    
    */
    int j = 5;
    j = *p;//*p等价于i的值
    //*p就是p的内容为地址的变量，*p和取地址互为逆运算
    
    printf("%d",j);//输出j=3
    return 0;
}
```

>  指针与指针变量

1、指针就是地址，地址就是内存单元的编号

2、指针变量是存放地址的变量，指针和指针变量是两个不同的概念

3、但是要注意：通常在叙述时会把指针变量简称为指针，实际他们含义并不一样



>  指针的重要性

1、表示一些复杂的数据结构

2、快速地传递数据

3、使函数返回一个以上的值

4、能直接访问硬件

5、能够方便地处理字符串

6、是理解面向对象语言中引用的基础

总结：指针是C语言的灵魂



## 指针的定义

（1）什么是地址

​		1、内存单元的编号

​		2、从零开始的非负整数

​		3、范围：4G【0——4G-1】

（2）什么是指针

​		指针就是地址，指针的本质就是操作受限的非负整数

## 指针的分类

​	1、基本类型的指针

​	2、

```c
//经典函数，利用指针交换两个数的值
//huhuan函数接受的是int* 类型的参数，也就是地址。huhuan(&a,&b);把a和b的地址传到函数，此时pa和pb分别指向a和b。huhuan函数得到a和b的地址后，通过*pa,*pb可以访问a和b的值，然后直接更改。即使函数执行完毕pa和pb被释放，但是a和b的值已经被更改。
# include<stdio.h>
void huhuan(int* pa,int* pb){
    int t;
    t = *pa;
    *pa = *Pb;
    *pb = t;
}

int main(void){
    int a = 3;
    int b = 5;
    huhuan(&a,&b);
    printf("a=%d,b=%d\n",a,b); //输出结果 5  3
    return 0;
}

```

指针和数组

（1）下标和指针的关系

​	1、一维数组名为该数组第一个元素的地址

​	2、如果p是个指针变量，则p[i]永远等价于*(p+1)

```c
//通过指针遍历数组
# include<stdio.h>
void arr(int* arr,int len){
	for(int i = 0;i < len; i++){
        printf("%d\n",*(arr+i));//输出1,2,3,4,5
    }
}

int main(void){
    int i[5] = {1,2,3,4,5}; 
    arr(i,5);
    return 0;
}


```

（2）一个指针变量占用几个字节

​		1、一个指针变量，无论它指向的变量占几个字节，该指针变量本身只占四个字节

​		2、一个变量的地址使用该变量首字节的地址来表示

## 动态内存分配

传统数组的缺点：

①数组长度必须事先制定，且只能是常整型，不能是变量。

```c
int a[5];//ok
int len	= 5;
int a[len];//error
```

②传统形式定义的数组，该数组的内存程序员无法手动释放。在一个函数运行期间，系统为该函数中数组所分配的空间会一直存在，直到该函数运行完毕时，数组的空间才会释放。

③数组的长度一旦定义，其长度不能再更改。

④传统数组在所定义的函数运行完毕后，数组会被释放



为什么需要动态内存分配

​	动态数组很好解决传统数组（静态数组）的缺陷

```c
# include <stdio.h>
# include <malloc.h>
int main(void){
    int *p = (int*)malloc(sizeof(int)*5);
    //动态创建长度为5的数组，总共20字节（因为int类型占4字节，4*5=20）
	p[0] = 1;//等价于*p = 1;
    p[1] = 2;//等价于*(p+1) = 2;
    printf("%d\n",p[0]);//输出1
    free(p);//释放p所指向的内存,可以随时释放
	printf("%d\n",p[0]);//由于p所指向的内存已经被释放，此时输出的可能为垃圾值
}


```

```c
int a(int*p){
    int *p = (int*)malloc(sizeof(int)*5); //p指向了该动态数组
    //动态创建的数组存储在堆中，即使函数执行完毕也不会被释放
    p[0] = 1;
}
int main(){
    int*p;
    a(p);
    printf("%d\n",p[0]);//1
}
```



## 多指针

```c
# include <stdio.h>
int main(void){
	int i = 5;
    int *p = &i;
    int **q = &p;
    int ***r = &q;
/*
 i  <—————p    <—————q   <—————r     
 5⬜    0x1⬜    0x2⬜    0x3⬜
  0x1      0x2      0x3       0x4

假设
i存储的值是5，0x1是i的地址;
p存储的值是0x1即i的地址，p本身的地址是0x2
q存储的值是0x2即p的地址，q本身的地址是0x3
r存储的值是0x3即q的地址，r本身的地址是0x4
则有r指向q，q指向p，p指向i
************************************
p的类型是int* ，q的类型是int** ,r的类型是int***
*p = i; 
**q = i;//*q = p, 等价于*(*q)
.......
*/
}
```

```c
void a(int** q){
    int j =10;
	*q = &j;
}
int main(){
    int* p;
    int i = 5;
    *p = i;
	printf("%d\n",*p);
    a(&p);
    printf("%d\n",*p);
}
```



## 结构体

为什么需要结构体

​	为了表示一些复杂的事物，而普通的基本数据类型无法满足实际需求

什么是结构体

​	把一些基本类型数据组合在一起形成的一个新的复合数据类型，叫做结构体

如何定义结构体

```c
//第一种方式,这只是定义一种新的数据类型，并没定义变量
Struct Student{
    int age;
    float score;
    char sex;
};

//第二种方式
Struct Student{
    int age;
    float score;
    char sex;
} stu;//定义时直接赋值

//第三种方式
Struct {
    int age;
    float score;
    char sex;
} stu;
```

如何使用结构体

```c
struct Student{
    int age;
    float score;
    char sex;
};
int main(void){
    struct Student st = {22,88.8,'N'};
    struct Student st2;
    st2.age = 18;
    st2.float = 66.6;
    st2.sex = 'N';
   	printf("%d %d %d\n",st.age,st.score,st.sex);
    return 0;
}
```

如何取出结构体变量中的每一个成员

​	1、结构体变量.成员名

​	2、指针变量->成员名（常用）

```c
struct Student{
    int age;
    float score;
    char sex;
};
int main(void){
    struct Student st = {22,88.8,'N'};
    struct Student *pst = &st;
    pst->age = 30;
    st.age = 20;
   	//printf("%d %d %d\n",st.age,st.score,st.sex);
    
    //pst->在计算机内部会被转化成(pst).age，所以pst->age等价于 (*pst).age也等价于st.age
    return 0;
}
```



# 枚举

```c
//只定义了数据类型，并没有定义变量
enum WeekDay{
    Monday,Tuesday,
};

int main(){
    enum WeekDay day = Monday;
    printf("%d",day);//输出0   
}
```

# 补码

> 已知十进制求二进制

​	求正整数的二进制：除2取余，直至商为零，余数倒叙排序

​	求负整数的二进制：先求与该负数相对应的正整数的二进制代码，然后将所有位取反，末尾加一，不够位数时左边补1

求零的二进制：全是零

> 已知二进制求十进制

​	如果首位是0，则表明是正整数，按普通方法来求

​	如果首位是1，则表明是负整数，将所有位取反，末尾加1，所得数字就是该负数的绝对值

如果全是零，则对应的十进制数字就是零

# 链表

头指针

头节点

尾节点



# 位运算符

&把两个数每个位按且进行比较

```
0110//二进制的6
0101//二进制的5

0&1 —— 0
1&0 —— 0
1&1 —— 1
0&0 —— 0

结果为0100 //4
```

|把两个数每个位按或进行比较



~所有位取反

```c
10110
取反 —— 01001    
```



^异或

1、<<按位左移

```c
i<<3 表示把i的所有二进制位左移3位，右边补零
```

左移n位相当于乘以2的n次方

2、>>按位右移

```c
i>>3 表示把i的所有二进制位右，左边一般是0，当然也可能是补1
```

右移n位相当于除以2的n次方，前提是数据不能丢失
